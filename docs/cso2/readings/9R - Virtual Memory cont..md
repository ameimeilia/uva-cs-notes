---
layout: default
title: Virtual Memory cont.
parent: Readings
nav_order: 8
---
# Virtual Memory cont.
### 2.1 Segments revisited
- **Segments**: Pairs of starting and stopping addresses with permissions, used internally by operating systems to represent memory regions.
- **Hardware Invisibility**: Segments are software-only constructs and are not visible to hardware.
    - The OS translates segments into **page table entries** for the hardware.
    - Handles **faults** (e.g., page faults) and converts them into **signals** like **`SIGSEGV`** for user processes.

*example - segment struct*
```
struct segment_node {
    void *low_address;
    void *high_address;
    unsigned int permissions_flags;
    struct segment_node *next;
}
```
- **Segfault**: A common term for a crash due to invalid memory access.
	- Technically incorrect—faults are generated by hardware (page/protection faults), but OS signals a **segmentation violation (SIGSEGV)**.
- **POSIX Functions**:
	- `mmap` and `munmap` adjust segments in memory, commonly wrapped by higher-level functions like `malloc`.
### 3.2 Multi-level page tables
- **Multi-level Page Tables**: A high-arity, fixed-depth tree structure.
    - Efficient for storing large, sparse arrays, especially when data is clustered.
- A data structure vital for managing virtual memory.
#### 3.2.1 Fixed-depth high-arity trees
**Tree Structure**: A tree where each node has an array of pointers to additional nodes.
- **High-arity trees**: Trees with more than two pointers per node (higher arity), commonly used in hardware-related structures.
- **Fixed-depth**: All data is stored the same number of steps from the root. Leaf nodes contain data, while internal nodes hold pointers.

*example - tree with arity 16, 3 intermediate levels*
```C
#define WIDTH 16

struct leaf {
    PAYLOAD data[WIDTH];
};
struct height1 {
    struct leaf *kids[WIDTH];
};
struct height2 {
    struct height1 *kids[WIDTH];
};
struct height3 {
    struct height2 *kids[WIDTH];
};

/* ... */

struct height3 *root = /* ... */
```
- This tree has the ability to store $16^4 = 65,536$ `PAYLOAD` values using a total of $1+16^1+16^2+16^3 = 1+16+256+4,096=4,369$ pointers

- The tree can be accessed like an array using bit masks
*example - function to access data*
```C
PAYLOAD arr(struct height3 *root, unsigned short index) {
    struct height2 *child1 = root  [(index>>12)&(WIDTH-1)];
    struct height1 *child2 = child1[(index>>8)&(WIDTH-1)];
    struct leaf    *child3 = child2[(index>>4)&(WIDTH-1)];
    return child3[index&(WIDTH-1)];
}
```

**Space Efficiency**: Saves memory when most indices are unused by omitting entire subtrees.
- Uses null checks to avoid allocating unused subtrees.
- More memory-efficient but slower due to multiple checks and memory accesses.
```C
PAYLOAD *arr(struct height3 *root, unsigned short index) {
    if (!root) return NULL;
    struct height2 *child1 = root  [(index>>12)&(WIDTH-1)];
    if (!child1) return NULL;
    struct height1 *child2 = child1[(index>> 8)&(WIDTH-1)];
    if (!child2) return NULL;
    struct leaf    *child3 = child2[(index>> 4)&(WIDTH-1)];
    if (!child3) return NULL;
    return &child3[index&(WIDTH-1)];
}
```
- only ten intermediate nodes and 5 × 16 = 80 `PAYLOAD` values are allocated rather than the 65,536 `PAYLOAD` values that would have been allocated for a simple array
#### 3.2.2 Multi-level page table implementation
- **Address Space Sparsity**
    - Programs often access only a small portion of the available 64-bit address space.
    - Example: Out of 18.4 quintillion possible addresses, only a few megabytes may be actively used.
    - This sparsity makes fixed-depth, high-arity trees a suitable choice for storing page table entries.
- **x86-64 Address Handling**
    - **Top 16 bits of virtual addresses are ignored**: x86-64 only uses 48 bits of the 64-bit address space.
    - **64-bit page table entries (PTEs)**: Used to map virtual page numbers (VPNs) to physical page numbers (PPNs).
    - **4KB pages are common**: Each page table node fits into one 4KB page.
- **Page Table Structure**
    - **4-level page table for 4KB pages**:
        - Each level adds 9 bits to the address calculation (9 + 9 + 9 + 9 + 12 = 48 bits).
    - **Other page sizes**:
        - 256KB pages: 2 levels of page tables (15 + 15 + 18 = 48 bits).
    - **Page size trade-offs**:
        - Smaller pages waste less memory but require more page table entries and deeper page tables.
        - Larger pages are more space-efficient but increase memory waste for partially used pages.
- **Mixed-Size Pages**
    - x86-64 supports a mix of **4KB and 2MB pages**.
    - 2MB pages are used for data but not for page table nodes, reducing the depth of the page table for some paths.
- **Address Translation Process**
	- The address translation process involves splitting the virtual address into 9-bit segments and walking through the page table levels:
    ```C
    size_t vpn[4] = split_bits(va>>12, 9);
    size_t ppn = PTBR;
    for(int i=0; i<4; i+=1) {
        PTE pte = ram[(ppn<<12) | (vpn[i]<<3)];
        if (pte.unmapped) page fault;
        if (pte.flags & current_usage) protection fault;
        ppn = pte.ppn;
    }
    pa = (ppn<<12) | (va & ((1<<12)-1));
    ```
- The hardware performs this translation, and any unmapped or protection violations result in faults handled by the operating system (OS).

- **Page Fault Handling**
	- When a page fault occurs, the OS steps in to handle it:
```C
handle_page_fault(size_t va, int access_type) {
    int flags = permitted_actions(va, segment_list);
    if ((access_type & flags) != access_type)
        send_signal(SIGSEGV);
    ssize_t ppn = get_unused_physical_page();
    if (ppn < 0) ppn = swap_page();
    create_page_table_entry(va, ppn, flags);
}
```
- `permitted_actions`: checks the OS list of segments to see what accesses the segment containing the address allows
- `get_unused_physical_page`: pull one page from the unused list onto the used by current process list.
- `swap_page`: if `get_unused_physical_page` fails to find an unused page, the OS picks a page currently being used by some process and swaps it out: 
	1. Picks a physical page
	2. Writes its contents onto a region of disk known as the swap space
	3. Changes the PTE for that page such that
	    1. the unmapped bit is set
	    2. the rest of the bits tell where the contents are located on disk
	4. Change that page to be owned by the current process
	5. Return the newly-freed physical page number
- `create_page_table_entry`: the OS must ensure the PTE is correctly created, including
	- Adding intermediate nodes in the page table.
	- Setting permissions and assigning the physical page number.
	- If a swapped-out page is referenced, its contents are reloaded into memory from disk.

The following depicts all of the lookups used by x86-64’s virtual memory system with 4K pages. Virtual addresses are in yellow, physical addresses in cyan, and page table entries in white.

![](https://www.cs.virginia.edu/~cr4bd/3130/F2024/Readings/address-trans.svg)

The three zero bits at the end of the first four physical addresses accomplish the index × 8 needed to compute the address of an 8-byte PTE by its index.

Of the above
- The user/compiler puts data in memory and picks the virtual address
- The OS puts the data into the PTBR and the PTEs into RAM
- The hardware does everything else depicted